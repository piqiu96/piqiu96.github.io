[{"categories":["MySQL"],"content":"MySQL事务 ","date":"2021-12-09","objectID":"/mysql-transaction/:0:0","tags":null,"title":"MySQL事务实现原理","uri":"/mysql-transaction/"},{"categories":["MySQL"],"content":"1、事务是什么？ 事务通常指的是逻辑上的一组操作，要么全部执行成功，要么全部执行失败。总体来说，他们具备ACID四大特性，分别是原子性（Atomioc）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）。其中，事务的隔离型由锁和MVCC机制实现啊，原子性和持久性由RedoLog实现，一致性由UndoLog实现的。 原子性：事务的所有操作要么全部成功，要么全部失败。 一致性：事务执行之前和执行之后，数据始终处于一致的状态。 隔离型：并行执行的两个事务互相不受干扰。 持久性：事务提交之后，此事务对数据的更改操作被持久化到数据库中，并且不会被回滚。 ","date":"2021-12-09","objectID":"/mysql-transaction/:0:1","tags":null,"title":"MySQL事务实现原理","uri":"/mysql-transaction/"},{"categories":["MySQL"],"content":"2、事务并发会产生什么问题？ 并发问题是程序无法避免的问题，核心是并发事务对同一临界资源进行操作，不进行管控就会产生不一致。 举个例子：假设有一张数据表，user(uid, account)，实际数据为user（123, 100） A、问题1：脏读 1. 事务A：insert into user value(456, 200); 未提交 2. 事务B：select account from user where uid = 456; 读到account的值为200 事务B中读到了事务A未提交数据，说明是脏读。 B、问题2: 不可重复读 1. 事务A：update account = account + 100 where uid = 123 2. 事务B：select account from user where uid = 123，该处读到的acount = 100（A未提交） 3. 事务A：commit 4. 事务B：select account from user where uid = 123，该处读到的acount = 200（A已提交） 事务B两次读同一数据，读到前后结果分别是100、200，说明是不可重复读。 C、问题3: 幻读 1. 事务A：select * from user; // 查询结果: user(123, 100) 2. 事务B：insert into user value(456, 200); commit; 3. 事务A: select * from user; // 查询结果：user(123, 100) 4. 事务A：update user set account = 300 where uid = 456; commit; // 刚刚查询结果还不存在uid=456，更新居然成功了！ 5. 事务A: select * from user; // 查询结果：user(123, 100)、user(456, 300) 从例子看，都是已提交的事务A对事务B造成了影响。不可重复读和幻读的区别是什么呢？ 不可重复读：主要是针对修改和删除动作，两次读的结果是不一样的，被称为不可重读（变化）。 幻读：主要是针对插入动作，第一次读不存在，第二次读存在，被称为幻读（有无）。 ","date":"2021-12-09","objectID":"/mysql-transaction/:0:2","tags":null,"title":"MySQL事务实现原理","uri":"/mysql-transaction/"},{"categories":["MySQL"],"content":"3、如何解决并发事务产生的问题？ 并发问题在程序中通常控制手段有两种：悲观锁（互斥锁、读写锁）、乐观锁（CAS + 数据多版本）。 3.1、在并发控制中，锁机制是如何演进的？ 我们知道，并发问题的核心是数据竞争，解决办法是临界资源管控(锁)。然而，锁机制演进的过程在本质上是性能和安全的折中。我们在应用程序中，解决并发问题通常手段有如下几种。 互斥锁：最简单粗暴的办法是互斥锁，读写全部都串行化。它的优点是安全，缺点是性能差。 读写锁：按理说读读是对数据一致性不会产生影响，于是读写锁产生实现读读并行，读写、写写串行，提升性能。 CAS+数据多版本：CAS是自旋锁摆脱锁机制，但是CAS会存在ABA问题，于是通过数据多版本来解决ABC问题保障安全。同时，实现读写并行，进一步提升性能。 名次解释：CAS（Compare And Swap）、ABA问题（百度一下） 总体思路，简单总结一下。 互斥锁：无论读还是写全部串行执行。 读写锁：读读并行执行，读写、写写串行执行。 数据多版本：读写并行执行。 3.2、MySQL中是如何解决并发问题的？ MySQL中是通过隔离性来保证，隔离性的底层实现是通过锁和MVCC（数据多版本）保证。从总体思路说，它的解决办法思路跟通常手段是一致的。谈到隔离性就不得不谈到隔离级别，事务中存在四种隔离级别分别是读提交、读已提交、可重复读、串行化。 3.2.1、这几种隔离级别是什么含义呢？ 举个例子：假设有一张数据表，user(uid, account)，实际数据为user（123, 100） A、读未提交 事务A：update account = account + 100 where uid = 123 事务B：select account from user where uid = 123，该处读到的account = 200（A未提交） 点评：事务A修改数据且提交，事务B马上可见，存在脏读。 B、读提交 事务A：update account = account + 100 where uid = 123 事务B：select account from user where uid = 123，该处读到的acount = 100（A未提交） 事务A：commit 事务B：select account from user where uid = 123，该处读到的acount = 200（A已提交） 点评：事务A修改数据且提交，事务B马上可见，存在不可重复读。 C、可重复读 简单说，事务在未提交前查询的同一条数据，无论读多少遍都不会改变。 事务B：select account from user where uid = 123，该处读到的acount = 100 事务A：pdate account = account + 100 where uid = 123；commit； （更新且提交） 事务B：select account from user where uid = 123，该处读到的acount = 100（A提交不影响B） 点评：事务A修改数据无论是否提交，事务B都不可见。 D、串行化 简单说，前一个事务没有提交事务前，下一个事务不允许进行数据操作，不过多赘述。 3.2.2、不同隔离级别分别能解决那些事务并发问题（脏读、不可重复读、幻读）？ 事务隔离级别 脏读 不可重复读 幻读 读未提交 可能 可能 可能 读已提交 不可能 可能 可能 可重复读 不可能 不可能 可能 串行化 不可能 不可能 不可能 读未提交：普通select不加锁 串行化：普通select隐式加锁，普通select全部转换成加锁select（select … in share mode） 可重复读（RR）：普通select为快照读，update/delete/加锁select（select … in share mode / for update）为当前读（行锁） 唯一索引查询条件（记录锁）、范围查询（间隙锁） 读已提交（RC）：普通select为快照读，update/delete/加锁select（select … in share mode / for update）为当前读（行锁） 唯一索引查询条件（记录锁），会产生幻读现象 3.2.3、Mysql是如何在可重复读隔离级别解决幻读问题的？ 众所周知，数据多版本只能解决可重复读问题（行记录多版本），并不能控制记录新增产生的幻读问题。MySQL中解决幻读问题，主要是通过间隙锁和记录锁。 间隙锁：本质上是事务未结束前，不允许其他记录新增记录。其中，间隙锁住要作用于范围查询。 假设有个数据库表,user(id, uid, account)，存在如下记录 user(1, 111, 100) user(2, 222, 200) user(20, 333, 300) user(24, 444, 400) 该数据表存在间系：[3,20)、[20,24),[25,+∞) 事务：select * from user id \u003e 20; // 这时候间隙[21,24)、[25, +∞]都会被间隙锁锁住，24会被记录锁锁住 3.2.4、MVCC（Multi Version Concurrent Control）是如何实现的？ 3.2.4.1、MVVC被称为多版本并发控制，什么是数据多版本？ 例3.2-1：假设有张数据表，数据表为user(uid, account)，初始化数据为user(123, 100) 执行SQL语句: start; update user set account = 200 where uid = 123; update user set account = 300 where uid = 123; update user set account = 400 where uid = 123; commit; 按照正常思想，执行完SQL的数据存储结构 user(123, 400) 按照数据多版本思想，执行玩SQL的数据存储结构 user(123, 100, V1) user(123, 200, V2) user(123, 300, V3) user(123, 400, V4) 注意：这里的快照是基于每一行的行数据变更快照。 据上总结，数据多版本就是将数据做冗余，存储每一个时刻行记录变更的镜像。那么，事务之间的数据镜像无依赖且能找到历史数据版本，从而实现数据读写并发、事务回滚。 3.2.4.2、MySQL的MVCC机制底层是如何实现的？ 行记录的隐藏列 假设我们来设计数据多版本，按照最简单思路（例3.2-1），不考虑资源限制条件下直接在磁盘存多份数据就能实现这种效果，但显然存在存储资源问题，故不会被采用。 那在Innodb存储引擎中如何实现做的呢？首先，在数据库中有个概念叫做隐藏列，也就是每一行数据都有隐藏列数据，它们分别是TRX_ID、ROW_ID、ROLLBACK_POINTER TRX_ID：更新该行数据的事务ID ROW_ID：该行的唯一标识ID（当无主键时存在） ROLLBACK_POINTER：回滚指针，它指向上一个版本，我们把指向的地址回滚段中undolog的指针 **undolog** **上面提到的undolog，什么意思？**undolog是食事务未提时，会将事务旧版本的数据存放于undolog日志里，当事务回滚或数据崩溃时，可以利用undo日志，撤销未提交事务对数据的影响。 undolog存什么？ insert：undolog日志存储新数据的ROW_ID(PK)，回滚时删除即可 delete/update：undolog存储旧版本数据的行记录，回滚时直接恢复即可 回滚段 回滚段是存储undolog的地方，一个回滚段对应一次事务执行的undolog集合（事务与回滚段的映射关系存在，便于快速查找到事务的历史数据版本快速回滚）。 快照（ReadView） 快照是什么？快照就是基于整库的某个时刻的镜像。在不同隔离级别下快照（READVIEW）产生时机不同，可重复读隔离级别是事务启动时产生快照，读已提交隔离级别是执行更新动作时产生快照。 首先，基于整库镜像，当然不是物理存储，假设整库100G，每个镜像100G，那数据库得崩溃。于是，就有了ReadView的数据结构来定义。 m_ids：当前系统中存活的事务id的列表 min_trx_id：当前系统中存活事务的最小事务id，即m_ids的最小值 max_trx_id：系统下一个即将分配的事务id，**即m_ids的最大值 + 1，**并不是m_ids的最大值 creator_trx_id：当前事务ID 其中，(-∞，min_trx_id)为已提交事务，[min_trx_id,max_trx_id)为未提交事务, [max_trx_id, +∞]为未开始事务。通过这个规则来定义进行快照读的时候，确认行记录是否可读。 如果落在已提交事务区间，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的； 如果落在未提交事务区间，表示这个版本是由将来启动的事务生成的，是肯定不可见的； 如果落在未开始事务区间，那就包括两种情况 若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见； 若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见。 总之，根据数据行中ROLLBAKCK_PTR能找到所有的回滚日志（历史版本数据），通过快照中事务活跃关系和数据行中TRX_ID来比对确定是否可读来执行快照读，最终实","date":"2021-12-09","objectID":"/mysql-transaction/:0:3","tags":null,"title":"MySQL事务实现原理","uri":"/mysql-transaction/"},{"categories":["MySQL"],"content":"4、事务的执行流程 4.1、事务是如何执行的？ 4.2、事务是如何回滚的？ 根据事务ID找到对应的回滚段中的undolog，将回滚段里的日志进行清空即可。 ","date":"2021-12-09","objectID":"/mysql-transaction/:0:4","tags":null,"title":"MySQL事务实现原理","uri":"/mysql-transaction/"},{"categories":["MySQL"],"content":"5、数据库事务是怎么实现的？ 参考：https://draveness.me/mysql-transaction/ 原子性和持久性由RedoLog实现，一致性由UndoLog实现，隔离性由MVCC和锁实现。 5.1、原子性\u0026持久性 严格说，原子性和持久性由RedoLog和UndoLog保证。当然，说RedoLog也是可接受的，因为UndoLog也会产生RedoLog。UndoLog的完整性和可靠性需要RedoLog保证，因此数据库崩溃时需要先做RedoLog恢复，然后再做UndoLog回滚。 总之，RedoLog的持久化保证了数据持久化到磁盘，又影响到UndoLog的可靠和完整，最终实现原子性和持久性。UndoLog用于对事务的影响进行撤销，RedoLog在错误处理时，对已提交的事务进行重做。 发生错误或需要回滚的事务能够成功回滚（原子性）； 在事务提交后，数据没得急写磁盘就宕机时，在下次重新启动后能够恢复数据（持久性）； 5.3、一致性 原子性\u0026持久性\u0026原子性都保证了，一致性就保证了。 不一致的时机：unlog、redolog、磁盘都可能出现不一致 A时机：写了redolog，写磁盘失败 redolog：数据页记录与磁盘页比较，通过回放实现磁盘和redolog的一致 B时机：事务已提交，redolog写失败 undolog/binlog：数据进行比较实现一致 5.4、隔离性 MVCC和锁 ","date":"2021-12-09","objectID":"/mysql-transaction/:0:5","tags":null,"title":"MySQL事务实现原理","uri":"/mysql-transaction/"},{"categories":["MySQL"],"content":"参考 MySQL技术内幕InnoDB存储引擎 深入理解分布式事务 https://draveness.me/mysql-transaction/ InnoDB-事务原理@www.corgiboy.com InnoDB并发如此高，原因竟然在这？@架构师之路 MySQL-InnoDB究竟如何巧妙实现，4种事务的隔离级别@架构师之路 https://www.cnblogs.com/rjzheng/p/10841031.html ","date":"2021-12-09","objectID":"/mysql-transaction/:0:6","tags":null,"title":"MySQL事务实现原理","uri":"/mysql-transaction/"},{"categories":["MySQL"],"content":"1、数据库与缓存不一致问题 ","date":"2021-12-09","objectID":"/mysql-design/:1:0","tags":null,"title":"MySQL设计与应用","uri":"/mysql-design/"},{"categories":["MySQL"],"content":"1.1、问题产生 为什么用缓存？ 提升读性能：db受限于磁盘限制，缓存基于内存，磁盘与内存的读性能想差甚远 会产生什么问题？ 数据不一致：数据冗余意味着不一致 ","date":"2021-12-09","objectID":"/mysql-design/:1:1","tags":null,"title":"MySQL设计与应用","uri":"/mysql-design/"},{"categories":["MySQL"],"content":"1.2、解决办法 要点：并发（时序）、异常情况 指标：缓存利用率、并发安全、一致性 1.2.1、MySQL单机版 最佳实践：先更新数据库，再删除缓存 方案一：更新数据库、更新缓存 思路 先更新数据库，再更新缓存 先更新数据库，再更新缓存 问题 异常问题：第一步更新成功，第一步更新失败，必将导致不一致。 并发问题：并发必将有时序问题。 例子 A线程更新数据库（X=1），B线程更新数据库（X=2） B线程更新缓存（X=2），A线程更新缓存（X=1） 结果：X的值，数据库=2，缓存=1，不一致持续时长取决于缓存过期时间 结论：该方案原则上不推荐使用，主要是时序问题无法保证 方案二：更新数据库、删除缓存 思路 先删除缓存，再更新数据库 先更新数据库，再删除缓存 问题 异常问题：跟第一种方案同理无法避免，异常必将导致不一致 并发问题 先删除缓存，再更新数据库 例子 1、线程A要更新X=2（原值X=1） 2、线程A先删除缓存 3、线程B读取缓存，发现不存在，从数据库读取旧值（X=1） 4、线程A将新值写入数据库（X=2） 5、线程B将旧值写入缓存（X=1） 结果：X的值，数据库=2，缓存=1 分析：读写请求并发，A、B线程交替读写，出现概率还是可能的。 先更新数据库，再删除缓存 例子 1、缓存中 X 不存在（数据库 X = 1） 2、线程 A 读取数据库，得到旧值（X = 1） 3、线程 B 更新数据库（X = 2) 4、线程 B 删除缓存 5、线程 A 将旧值写入缓存（X = 1） 结果：X的值，数据库=2，缓存=1 分析：出现时机且满足以下三个条件，现实中出现概率较少，存在理论上的可能 线程A读请求时，缓存已失效 读写请求并发 步骤2中读时长 \u003e 「步骤3+步骤4」中的「更新+删除」动作总时长概率较低 结论：「先更新数据库，再删除缓存」从分析结果来看能绝大概率解决并发问题，是该命中的最佳实践。 根据「先更新数据库，再删除缓存」仅解决并发问题，如何解决异常问题？ 思路一：一致性要求不高，容忍短暂不一致，等待缓存到过期时间，不处理 思路二：删缓存动作失败，尝试充实重试 同步重试：仅在网络抖动丢包的情况 异步重试：写MQ异步读取消费，MQ需保证可靠性直到消费成功 思路三：监听MySQL的binlog，思路就跟主从原理类似，实现缓存同步。 市场上现有工具可参考阿里的canal，「数据库+缓存」、「数据库 + es索引」 1.2.2、MySQL主从 + 读写分离 问题：MySQL主从 + 读写分离架构中，读请求存在延迟导致不一致？ 线程 A 更新主库 X = 2（原值 X = 1） 线程 A 删除缓存 线程 B 查询缓存，没有命中，查询「从库」得到旧值（从库 X = 1） 从库「同步」完成（主从库 X = 2） 线程 B 将「旧值」写入缓存（X = 1） 结果： X 的值在缓存中是 1（旧值），在主从库中是 2（新值），也发生不一致。 分析：在有大事务或资源抢占明显时，主从延时的概率还是存在的，故发生的概率还是会存在 思路：根据经验，预估主从延时时间，将缓存再次删除 方案一：更新数据库，删除缓存，休眠等待延时时间，再次删除缓存 方案二（推荐）：更新数据库，将删动作写入延时队列（延时时间根据经验1-5s），定期消费消息执行删除动作 方案三：选择性读主，更新数据库时，记录「库 + 表 + pk」作为键记录到缓存中，读db时根据该键决定是否读主 总结：最佳实践选择「先更新数据库，再删除缓存」的方案实现数据库与缓存一致，根据业务一致性要求和MySQL主从+读写分离架构考虑是否要使用延迟删除方案。 实践：写多读少场景保db高可用，读多写少做缓存高可用 + 容灾缓存。 其他：很多时候，缓存也存在主从架构，甚至还有跨机房延迟等情况，实际从理论上提出完美方案就非常复杂了。最佳办法还是保证每一个子系统子服务保证一致，写的代码保障高质量避免极端情况出现，故才能达到全局最优的方案。 ","date":"2021-12-09","objectID":"/mysql-design/:1:2","tags":null,"title":"MySQL设计与应用","uri":"/mysql-design/"},{"categories":["MySQL"],"content":"2、数据库与ES同步 问题起源：在用户产品研发中，经常会碰到很多复杂多样的查询，如标签、分类、人群等，而实际的元数据却存在于关系型数据库MySQL，关系型数据库对于复杂查询很难支持，同时它也不适合承担太多索引的职责。于是，引入ES充当索引角色，也就是形成复杂标签与原数据ID成映射关系。 读请求：查询es索引，找到索引与元数据ID，通过元数据ID查MySQL具体数据，最终返回 写请求 方式一（同步写）：写MySQL、写ES索引，存在写失败问题，扩展性也不好 方式二（异步写） 来源一：监听MySQL的binlog，将binlog写入MQ，解析binlog将数据同步到ES 来源二：业务制定日志规范，打印用户日志，采集用户日志，流式计算日志，将日志导入ES ","date":"2021-12-09","objectID":"/mysql-design/:2:0","tags":null,"title":"MySQL设计与应用","uri":"/mysql-design/"},{"categories":["MySQL"],"content":"参考资料 数据库与缓存一致性问题@水滴与银弹 ","date":"2021-12-09","objectID":"/mysql-design/:3:0","tags":null,"title":"MySQL设计与应用","uri":"/mysql-design/"},{"categories":["效率工具"],"content":"图床 网址：https://www.jsdelivr.com/?docs=gh 示例：https://cdn.jsdelivr.net/gh/piqiu96/aqiucdn/imgs/wxicon2.jpg ","date":"2021-12-05","objectID":"/%E5%86%99%E4%BD%9C%E5%B7%A5%E5%85%B7/:1:0","tags":["写作"],"title":"写作工具","uri":"/%E5%86%99%E4%BD%9C%E5%B7%A5%E5%85%B7/"},{"categories":["效率工具"],"content":"公众号排版 https://www.mdnice.com/ http://md.aclickall.com/ http://blog.didispace.com/tools/online-markdown/ ","date":"2021-12-05","objectID":"/%E5%86%99%E4%BD%9C%E5%B7%A5%E5%85%B7/:2:0","tags":["写作"],"title":"写作工具","uri":"/%E5%86%99%E4%BD%9C%E5%B7%A5%E5%85%B7/"},{"categories":["效率工具"],"content":"代码排版 https://carbon.now.sh/ ","date":"2021-12-05","objectID":"/%E5%86%99%E4%BD%9C%E5%B7%A5%E5%85%B7/:3:0","tags":["写作"],"title":"写作工具","uri":"/%E5%86%99%E4%BD%9C%E5%B7%A5%E5%85%B7/"},{"categories":["算法"],"content":"排序算法 ","date":"2021-10-31","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:0:0","tags":null,"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"一、算法分类 插入排序 直接插入排序 希尔排序 交换排序 冒泡排序 快速排序 选择排序 简单选择排序 堆排序 归并排序 二路归并排序（递归实现） ","date":"2021-10-31","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:1:0","tags":null,"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"二、算法实现 ","date":"2021-10-31","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:2:0","tags":null,"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"2.1、插入排序 2.1.1、直接插入排序 数组：12,15,9,20,6,31,24,2,17,35 有序区{12,15} 无序区{9,20,6,31,24,2,17,35} 思路： 将无序区的第一个元素，称为候选元素。 将候选元素与有序区元素比较，选择适当位置插入。 public class InsertionSort { public static void sort(int [] array){ for(int i=1;i\u003carray.length;i++){ for(int j=i;j\u003e=1 \u0026\u0026 array[j]\u003carray[j-1];j--){ int temp =array[j]; array[j]=array[j-1]; array[j-1]=temp; } } } public static void main(String [] args){ int [] array={12,15,9,20,6,31,24,2,17,35}; InsertionSort.sort(array); System.out.println(Arrays.toString(array)); } } 2.1.2、希尔排序 产生：直接插入排序在基本正序的时候，排序效率高，所以把数组拆分很多个小数组，进行简单排序 思路： 将数组分组，间距从[d=n/2-1]，变换d=d/2 分别将不同分区进行直接插入排序。 当d=1，合并所有的分区进行直接插入排序 public class ShellSort { //采取分区 public static void sort(int [] array){ for(int d=array.length/2;d\u003e=1;d=d/2){ insertSort(array,d); } } //插入排序 public static void insertSort(int [] array,int d){ for(int i=d;i\u003carray.length;i++){ for(int j=d;j\u003e=d \u0026\u0026 array[j]\u003carray[j-d];j=j+d){ int temp=array[j]; array[j]=array[j-d]; array[j-d]=temp; } } } public static void main(String [] args){ int [] array={12,15,9,20,6,31,24,2,17,35,5}; InsertionSort.sort(array); System.out.println(Arrays.toString(array)); } } ","date":"2021-10-31","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:2:1","tags":null,"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"2.2、交换排序 2.2.1、冒泡排序 数组：12,15,9,20,6,31,24,2,17,35 无序区：{12,15,9,20,6,31,24,2,17} 有序区：{35} 问题： 如何确定需要冒泡排序范围，保证有序记录不参加下一趟的排序？ 如何判断冒泡排序结束？ 思路： 从数组头开始，候选元素跟后继元素比较，通过交换选出最大元素，直到无序区选出最大元素放入有序区的。 记录有序区的头索引，将不参加下一趟排序。 当没有元素交换，冒泡排序结束。 public class BubbleSort { public static void sort(int [] array){ int exchange=array.length; //判断无序列是否有交换，冒泡排序结束标志 while(exchange!=0){ //无序区的边界 int bound=exchange; exchange=0; for(int i=1;i\u003cbound;i++){ if(array[i]\u003carray[i-1]){ int temp=array[i]; array[i]=array[i-1]; array[i-1]=temp; exchange=i; } } } } public static void main(String [] args){ int [] array={12,15,9,20,6,31,24,2,17,35,5}; BubbleSort.sort(array); System.out.println(Arrays.toString(array)); } } 2.2.2、快速排序 数组：12,15,9,20,6,31,24,2,17,35 思路： 一次快速划分。选择轴值，最终轴值左侧小于轴值，轴值右侧大于轴值。 例如：最初选择轴值为12，通过一次快速划分，{2,6,9,12,15,20,17,35,31} 对轴值左侧、轴值右侧。 递归调用一次快速划分。 public class QuickSort { public static int partition(int [] array,int low,int high){ int i=low; int j=high; int temp; //当i==j,结束一次快速划分 while(i\u003cj){ //向右侧扫描 while(i\u003cj \u0026\u0026 array[i]\u003carray[j]) j--; //说明轴值大于array[j],交换轴值变成array[j] if(i\u003cj){ temp=array[i]; array[i]=array[j]; array[j]=temp; i++; } //向左侧扫描 while(i\u003cj \u0026\u0026 array[i]\u003carray[j]) i++; if(i\u003cj){ temp=array[i]; array[i]=array[j]; array[j]=temp; j--; } } return i; } public static void sort(int [] array,int low,int high){ if(low\u003chigh){ int mid =partition(array, low, high); sort(array, low, mid-1); sort(array, mid+1, high); } } public static void main(String [] args){ int [] array={12,15,9,20,6,31,24,2,17,35,5}; QuickSort.sort(array, 0, array.length-1); System.out.println(Arrays.toString(array)); } } ","date":"2021-10-31","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:2:2","tags":null,"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"2.3、选择排序 2.3.1、简单选择排序 数组：12,15,9,20,6,31,24,2,17,35 有序区：{} 无序区：{12,15,9,20,6,31,24,2,17,35 } 思路 把无序区的最小元素，采用选择方式放入有序区末尾 public class SelectSort { public static void sort(int [] array){ int index; for(int i=0; i\u003carray.length; i++){ index=i; for(int j=i; j\u003carray.length; j++){ if(array[j] \u003c array[index]) index = j; } if(index != i){ int temp = array[i]; array[i] = array[index]; array[index] = temp; } } } public static void main(String [] args){ int [] array={12,15,9,20,6,31,24,2,17,35,5}; SelectSort.sort(array); System.out.println(Arrays.toString(array)); } } 2.3.2、堆排序 数组：12,15,9,20,6,31,24,2,17,35 思路： 把候选元素构建成大根堆。 从数组最后一个元素开始遍历，把大根堆的最大元素放入有序区。 去掉有序区元素，重新调整大根堆。 public class HeapSort { //根据候选元素，构建成大根堆 public static void adjustHeap(int [] array,int i,int len){ int j=0; int temp=array[i]; for(j=i*2;j\u003clen;j=j*2){ if( j\u003clen \u0026\u0026 array[j]\u003carray[j+1]) j++; if(temp\u003e=array[j]) break; array[i]=array[j]; i=j; } array[i]=temp; } public static void sort(int [] array){ int i; //选非叶子节点，构造大根堆 for(i=array.length/2-1;i\u003e=0;i--){ adjustHeap(array, i, array.length-1); } //不断选大根堆最大元素放入有序区 for(i=array.length-1;i\u003e=0;i--){ int temp=array[0]; array[0]=array[i]; array[i]=temp; adjustHeap(array, 0, i-1); } } public static void main(String [] args){ int [] array={12,15,9,20,6,31,24,2,17,35,5}; HeapSort.sort(array); System.out.println(Arrays.toString(array)); } } ","date":"2021-10-31","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:2:3","tags":null,"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"2.4、归并排序 2.4.1、二路归并排序 数组：12,15,9,20,6,31,24,2,17,35 思路： 利用一次归并算法将两个分区元素，归并到一个数组里。 先把数组划分成长度为1的序列区间，利用递归的方式，归并到一个序列里。 public class MergeSort { public static void merge(int [] array,int low,int mid,int high){ int [] tempArray=new int[high-low+1]; int i=low; int j=mid+1; int k=0; while(i\u003c=mid \u0026\u0026 j\u003c=high){ if(array[i]\u003c=array[j]){ tempArray[k++]=array[i++]; }else{ tempArray[k++]=array[j++]; } } //把第一个分片序列，处理余下数据 while(i\u003c=mid){ tempArray[k++]=array[i++]; } //把第二个分片序列，处理余下数据 while(j\u003c=high){ tempArray[k++]=array[j++]; } //把临时数组的数据加入到原数组 for(int k2=0;k2\u003ctempArray.length;k2++){ array[low+k2]=tempArray[k2]; } } public static void sort(int [] array,int low, int high){ int mid=(low+high)/2; if(low\u003chigh){ sort(array, low, mid); sort(array, mid+1, high); merge(array, low, mid, high); } } public static void main(String [] args){ int [] array={12,15,9,20,6,31,24,2,17,35,5}; MergeSort.sort(array,0,array.length-1); System.out.println(Arrays.toString(array)); } } ","date":"2021-10-31","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:2:4","tags":null,"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["推荐书单"],"content":"📚 经典技术书籍 PDF 文件，涵盖：编程语言、计算机系统、网络协议、数据库、代码艺术、设计模式、算法与数据结构、系统架构、微服务、测试、程序员职业修炼等相关书籍。 版权原因，保留书单 可以找找别人的 fork 版本 ","date":"2021-10-14","objectID":"/booklist/:0:0","tags":["读书"],"title":"经典书单","uri":"/booklist/"},{"categories":["推荐书单"],"content":"Java 《Effective Java 中文版（第 2 版）》 《Java 编程思想（第 4 版）》 ","date":"2021-10-14","objectID":"/booklist/:1:0","tags":["读书"],"title":"经典书单","uri":"/booklist/"},{"categories":["推荐书单"],"content":"C 《C 程序设计语言（第 2 版）》 《C 专家编程》 《C 语言接口与实现》 《C 陷阱与缺陷》 ","date":"2021-10-14","objectID":"/booklist/:2:0","tags":["读书"],"title":"经典书单","uri":"/booklist/"},{"categories":["推荐书单"],"content":"C++ 《C++ Primer Plus（第 5 版）》 《C++编程思想（第 1 卷）》 ","date":"2021-10-14","objectID":"/booklist/:3:0","tags":["读书"],"title":"经典书单","uri":"/booklist/"},{"categories":["推荐书单"],"content":"Golang 《Go 学习笔记（第 4 版）》 《Go 学习笔记（第 6 版下卷）》 《Go 源码剖析》 《Go 程序设计语言》 《Go 语言实战》 ","date":"2021-10-14","objectID":"/booklist/:3:1","tags":["读书"],"title":"经典书单","uri":"/booklist/"},{"categories":["推荐书单"],"content":"Python 《Python 基础教程（第 2 版）》 《Python 编程：从入门到实践》 《Python 核心编程（第 2 版）》 《Python Cookbook（第 3 版）》 《Python 源码剖析》 ","date":"2021-10-14","objectID":"/booklist/:3:2","tags":["读书"],"title":"经典书单","uri":"/booklist/"},{"categories":["推荐书单"],"content":"Computer system 《深入理解计算机系统》 《现代操作系统（第 4 版）》 《编码：隐匿在计算机软硬件背后的语言》 《计算机程序的构造和解释（第 2 版）》 《计算的本质：深入剖析程序和计算机》 《编译原理（第 2 版）》 ","date":"2021-10-14","objectID":"/booklist/:4:0","tags":["读书"],"title":"经典书单","uri":"/booklist/"},{"categories":["推荐书单"],"content":"Linux / Unix 《UNIX 编程艺术》 《UNIX 环境高级编程（第三版）》 《UNIX 网络编程卷 1：套接字 API》 《UNIX 网络编程卷 2：进程间通信》 《UNIX 操作系统设计》 《Linux 内核设计与实现（第三版）》 《深入 Linux 内核架构》 《深入理解 linux 内核（第三版）》 《跟我一起写 makefile》 ","date":"2021-10-14","objectID":"/booklist/:5:0","tags":["读书"],"title":"经典书单","uri":"/booklist/"},{"categories":["推荐书单"],"content":"TCP 《TCP/IP 详解 卷 1：协议》 《TCP/IP 详解 卷 2：实现》 《TCP/IP 详解 卷 3：TCP 事务协议，HTTP，NNTP 和 UNIX 域协议》 ","date":"2021-10-14","objectID":"/booklist/:6:0","tags":["读书"],"title":"经典书单","uri":"/booklist/"},{"categories":["推荐书单"],"content":"HTTP 《HTTP 权威指南》 《Web 性能权威指南》 《图解 HTTP》 ","date":"2021-10-14","objectID":"/booklist/:7:0","tags":["读书"],"title":"经典书单","uri":"/booklist/"},{"categories":["推荐书单"],"content":"Clean code 《代码整洁之道》 《代码大全》 《编写可读代码的艺术》 《修改代码的艺术》 《重构：改善既有代码的设计》 《程序设计方法》 《程序设计实践》 《领域驱动设计：软件核心复杂性应对之道》 ","date":"2021-10-14","objectID":"/booklist/:8:0","tags":["读书"],"title":"经典书单","uri":"/booklist/"},{"categories":["推荐书单"],"content":"Design pattern 《Head First 设计模式》 《设计模式：可复用面向对象软件的基础》 《设计模式之禅》 ","date":"2021-10-14","objectID":"/booklist/:9:0","tags":["读书"],"title":"经典书单","uri":"/booklist/"},{"categories":["推荐书单"],"content":"Algorithms 《算法（第 4 版）》 《算法导论（第 2 版）》 《算法设计与分析（第 3 版）》 《算法心得：高效算法的奥秘（第 2 版）》 《数据结构与算法分析：C 语言描述（第 2 版）》 《数据结构与算法分析：Java 描述》 《编程珠玑（第 2 版）》 《编程之美：微软技术面试心得》 《剑指 offer 名企面试官精讲典型编程题》 ","date":"2021-10-14","objectID":"/booklist/:10:0","tags":["读书"],"title":"经典书单","uri":"/booklist/"},{"categories":["推荐书单"],"content":"System 《高性能网站建设指南》 《大型网站技术架构：核心原理与案例分析》 《企业应用架构模式》 《企业集成模式：设计、构建及部署消息传递解决方案》 ","date":"2021-10-14","objectID":"/booklist/:11:0","tags":["读书"],"title":"经典书单","uri":"/booklist/"},{"categories":["推荐书单"],"content":"Microservice 《微服务设计》 ","date":"2021-10-14","objectID":"/booklist/:12:0","tags":["读书"],"title":"经典书单","uri":"/booklist/"},{"categories":["推荐书单"],"content":"Test 《测试驱动开发》 ","date":"2021-10-14","objectID":"/booklist/:13:0","tags":["读书"],"title":"经典书单","uri":"/booklist/"},{"categories":["推荐书单"],"content":"Git 《Pro Git 中文版》 《GitHub 入门与实践》 ","date":"2021-10-14","objectID":"/booklist/:14:0","tags":["读书"],"title":"经典书单","uri":"/booklist/"},{"categories":["推荐书单"],"content":"Docker 《Docker 从入门到实践（第 3 版）》 《Docker 容器与容器云（第 2 版）》 ","date":"2021-10-14","objectID":"/booklist/:15:0","tags":["读书"],"title":"经典书单","uri":"/booklist/"},{"categories":["推荐书单"],"content":"MySQL 《高性能 MySQL（第 3 版）》 《MySQL 性能调优与架构设计》 《MySQL 技术内幕：InnoDB 存储引擎》 《SQL 基础教程（第 3 版）》 《MySQL 必知必会》 《SQL 学习指南》 ","date":"2021-10-14","objectID":"/booklist/:16:0","tags":["读书"],"title":"经典书单","uri":"/booklist/"},{"categories":["推荐书单"],"content":"MongoDB 《MongoDB 实战》 《MongoDB 权威指南》 《深入学习 MongoDB》 ","date":"2021-10-14","objectID":"/booklist/:17:0","tags":["读书"],"title":"经典书单","uri":"/booklist/"},{"categories":["推荐书单"],"content":"Redis 《Redis 入门指南（第 2 版）》 《Redis 实战》 《Redis 设计与实现》 《Redis 开发与运维》 ","date":"2021-10-14","objectID":"/booklist/:18:0","tags":["读书"],"title":"经典书单","uri":"/booklist/"},{"categories":["推荐书单"],"content":"Nginx 《深入理解 Nginx：模块开发与架构解析（第 2 版）》 ","date":"2021-10-14","objectID":"/booklist/:19:0","tags":["读书"],"title":"经典书单","uri":"/booklist/"},{"categories":["推荐书单"],"content":"Others 《如何阅读一本书》 《七周七语言：理解多种编程范型》 《程序员修炼之道：从小工到专家》 《程序员的职业素养》 《程序员的自我修养：链接、装载与库》 《高效程序员的 45 个习惯》 ","date":"2021-10-14","objectID":"/booklist/:20:0","tags":["读书"],"title":"经典书单","uri":"/booklist/"},{"categories":null,"content":"一、概念 ","date":"2020-12-04","objectID":"/git%E5%AE%9E%E6%88%98/:1:0","tags":null,"title":"Git速查","uri":"/git%E5%AE%9E%E6%88%98/"},{"categories":null,"content":"1.1. Git是什么？ GIT是分布式版本控制系统，简单分解就是：分布式 + 版本控制 + 系统，核心要素就是版本控制。 问题：怎么理解版本控制，想想我们生活工作中的场景？ 1、假设没有版本控制系统，你上线代码会做什么事情？（假设你不做，出现问题你怎么办？） 备份原文件，重命名 niubi.php.20200520 复制修改后文件移动到制定项目路径 2、当我们还是单机mysql数据库，对稳定要求不高，只需具备快速切换能力即可，这种场景你会怎么做？ 方案一：对数据库做版本控制，定时dump数据库文件，数据库文件名（XX.sql.时间时刻） 方案二：做数据库主从，主库挂掉，脚本快速切换到从库 3、当你写毕业论文的时候，写了N年的论文丢了你怕不怕，为了防止这操作你常见的操作是什么？ 老师想看论文，阿邱同学提交论文，命名：阿邱同学毕业论文_V1 老师想看论文，阿邱同学提交论文，命名：阿邱同学毕业论文_V2 …… 老师想看论文，阿邱同学提交论文，命名：阿邱同学毕业论文_V死不改版 本质上，版本控制本质上就是把每次文件（数据）集合打个标记（版本），让自己快速跳转到目标版本。最终，实现代码可以随意切换到随意版本的代码，当出现问题能快速切换到稳定版本。 ","date":"2020-12-04","objectID":"/git%E5%AE%9E%E6%88%98/:1:1","tags":null,"title":"Git速查","uri":"/git%E5%AE%9E%E6%88%98/"},{"categories":null,"content":"1.2 为什么要用Git？ 不管人类还是软件，都会遇到类似的问题，版本控制系统诞生无非是苦秦久矣罢了。还有细心思考下，不光是代码，凡是需要存储的内容（文件、数据库）都需要版本控制，不然任何一环故障都会影响系统。 其实，在Git出现前就出现很多版本控制系统，主流思想无非就是增量或全量，Git采用的全量快照的方式，把修改的文件集合打个版本。 增量：每次记录变化的内容，恢复的时候依据 基准版本 + 增量版本回滚。 全量：每次记录本次变更的所有文件放入缓存区，恢复的时候直接缓存区找到全量版本回滚。 于是，GIt有几个核心流程和核心概念。 核心概念：文件流转状态（已提交、已修改、已暂存），为了可通过文件状态跟踪出文件内容，于是git项目有三个阶段：工作区、暂存区以及 Git 目录。 核心流程： 在工作区中修改文件。 将你想要下次提交的更改选择性地暂存，这样只会将更改的部分添加到暂存区。 提交更新，找到暂存区的文件，将快照永久性存储到 Git 目录。 ","date":"2020-12-04","objectID":"/git%E5%AE%9E%E6%88%98/:1:2","tags":null,"title":"Git速查","uri":"/git%E5%AE%9E%E6%88%98/"},{"categories":null,"content":"二、实战 场景一：添加如何代码，提cr git pull git add \u003cfile\u003e git commit -m \"commit message\" 场景二：回滚commit 说明 提交非预期代码，需要回滚重新提交 git log git reset --soft '版本号' git reset --soft HEAD^ 回滚到上次提交 场景三: 切换分支且拉取代码 说明 主要用于项目初始化，切换分支且拉取代码 git branch -a git checkout -b \u003cbranch_local\u003e orign/\u003cbranch_remote\u003e baranch_local: 本地分支名，可自定义随意 branch_remote：远程分支名，必须是仓库内名 场景四：多个commit合并 说明 通常情况，我们设置一次CR只允许一次commit，如何把多次commit合并到同一commit？ git reset --soft HEAD^ git commit --amend git push origin \u003cremote\u003e 场景五：代码冲突 说明 代码冲突是最常见的问题，也是很头大的问题 方法一：保留服务器改动，仅合入远程仓库新增配置项，标记出冲突代码！ git stash git pull git stash pop 方法二：用远程仓库代码库文件完全覆盖本地文件，强制回滚！（慎用） git reset --hard git pull ","date":"2020-12-04","objectID":"/git%E5%AE%9E%E6%88%98/:2:0","tags":null,"title":"Git速查","uri":"/git%E5%AE%9E%E6%88%98/"},{"categories":null,"content":"参考资料 https://www.liaoxuefeng.com/wiki/896043488029600 https://git-scm.com/book/zh/v2 ","date":"2020-12-04","objectID":"/git%E5%AE%9E%E6%88%98/:3:0","tags":null,"title":"Git速查","uri":"/git%E5%AE%9E%E6%88%98/"},{"categories":["个人成长"],"content":"1、问题 经常有些读者在后台问一些指导性的问题，让我冷不丁去回答，给出建议都是碎片化的，无法形成有效可落地的建议。 举个例子 我学习什么能进入优秀的互联网公司工作？ 我现在大X，我想做软件研发我应该学习什么？ 众所周知，这问题就像你问学霸说你这么厉害一样让人难以回答。我作为一个资质和背景平凡的软工本科学生，经过大学自己摸索和不断试错，毕业开始在百度从事研发工作。其实，我当时也有很多类似的疑惑，在这里给大家讲讲我的踩坑历程。 记忆中，我当年逛知乎、求助高人、甚至我的导师，都无法给出一个可执行的建议。除此之外，在我那种普通的双非学校，知名企业都不会去咱学校校招，我和学长们对春秋招的概念微乎其微，进大厂是件很困难的事情，概率与踩狗屎不相上下。 作为探路者，求助知乎和论坛，给出的结论几乎都是好好学习数据结构/算法、现在大数据很火你应该学学Hadoop/Spark、你要是会微服务、docker、k8s一定会很加分。 让我想起了我当年问学霸考试题目如何解？学霸说：这个题目是来源于第X章第X例题，你这样解，答案就出来了，很容易的。至于为什么他能想到，鬼也不知道。 当时，我真的是花里胡哨的啥都学，啥都去倒腾，不知道是不是梁静茹给我的勇气。前端、后端技术栈、Hadoop/Spark、docker/k8s这些几乎都实操过，只是很多只是入门并没有深入研究，效果自然也十分有限。 这些概念，对于小白或者在校生来说，这仿佛在对说你不用学了，除非你天生技术欲望特别强烈。这对于大多数普通人来说，明显是劝退的节奏，可操行十分有限，几乎没有参考价值，不知道从何下手。 其实，道理是没有错的，多研究底层和热门技术栈是有益的。但是，脱离实际情况谈技术就是扯犊子，就像让中国男足拿世界杯冠军显然不符合实际，更应该是根据实际情况，做产出最大的事情，否则会信心全无。 接下来，我系统性拆分问题，在不同阶段应该「学什么」、「如何学」、「学到什么程度」，重点讲我当时遇到的问题，还有我是如何去思考的，最终如何解决的，思路比结论重要。 ","date":"2019-12-05","objectID":"/%E5%A4%A7%E5%AD%A6%E4%BA%BA%E7%94%9F/:1:0","tags":null,"title":"大学四年，如何成为还算不错的程序员？","uri":"/%E5%A4%A7%E5%AD%A6%E4%BA%BA%E7%94%9F/"},{"categories":["个人成长"],"content":"2、思路 首先，说说在大厂工作都是些什么样的人，他们当年都是背着什么光环混进去的？经过我的调研和分析，主要有如下五点指标。 举个例子 学历/专业、扎实专业基本功 有成果的科研经历 省/国家级软件设计大赛 丰富互联网公司实习经历 小有名气的开源项目经历 大概思路就是，要么你证明你令人信服的天赋如逻辑系统思维、聪明，让人觉得你可以被快速培养；要么你有丰富的工程实战经验，证明你具备优秀工程师的潜质。 当然，你可能会说这么多要求，恐怕神仙也做不到啊，简直太苛刻了。在这里，我想说的是并不是上述所有指标全部满足，只是满足其中2-3项能证明你的实力即可，毕竟面试时间十分有限必须有点让人信服的东西啊。 举个例子 假设你是上海交大、华中科大大学毕业的学生，你可能重点复习数据结构算法/计算机基础等专业知识，辅之把学校的科研经历着重阐述一下。可能进入什么腾讯阿里华为百度难度也不是很大，专业知识对于你们来说自己不再话下，毕竟这些都是你们的专长。 假如你是双非大学毕业的学生，那么你必须用国家级大赛、开源项目、互联网公司实习经历证明自己。总之，多做项目，专注于技术本身，让自己更早具备职业软件工程师的实战技能。 简而言之，你没有光环，那就比别人多努力点，提前做好职业规划，把时间投入技术本身不要投机取巧。 ","date":"2019-12-05","objectID":"/%E5%A4%A7%E5%AD%A6%E4%BA%BA%E7%94%9F/:2:0","tags":null,"title":"大学四年，如何成为还算不错的程序员？","uri":"/%E5%A4%A7%E5%AD%A6%E4%BA%BA%E7%94%9F/"},{"categories":["个人成长"],"content":"3、落地 鉴于上述分析，我们知道了需求是什么？对我们来说，应把精力重点投入到技术本身、精益求精。这时候，我们将遇到一系列问题。 我应该做什么方向？（方向） 我应该学习什么内容？（规划） 我如何学这些内容？（方法/策略） 我应该学到什么程度？（量化） 如何把理论用到实际项目/产品中？（产出） ","date":"2019-12-05","objectID":"/%E5%A4%A7%E5%AD%A6%E4%BA%BA%E7%94%9F/:3:0","tags":null,"title":"大学四年，如何成为还算不错的程序员？","uri":"/%E5%A4%A7%E5%AD%A6%E4%BA%BA%E7%94%9F/"},{"categories":["个人成长"],"content":"3.1、方向\u0026规划 不同方向，意味着不同领域不同，学习的知识和实战项目有共性也有差异。在这里，我主要讲一下通用的思路。重点拿我擅长方向举例，其他方向可按照同样思路举一反三。 根据我的经验，可将内容分为原理、应用、擅长方向三个纬度。原理和应用纬度必须学习，方向纬度根据自己擅长方向深入学习。 原理：计算机网络、操作系统、数据结构/算法，这些东西都是专业课好好学即可，数据结构/算法日常多刷刷题，大不可必研究特么深入，待校招前留出时间来重点突击和复习即可。 应用：它是最基础的内容，不管你从事什么领域都将离不开它们。这也是小白入门重点花费时间的地方，你将在这里不断与程序斗争如调试、验证、异常、解决。 方向：不同方向本质上就是在基础应用上扩充，发挥它们擅长领域和特性去解决特定问题。 举个例子 后端开发方向：数据库、缓存、消息队列、rpc、微服务 大数据开发方向：Hadoop、Spark、Storm、Flink 自动化运维方向：elk、ansible、zabbix、docker、k8s ","date":"2019-12-05","objectID":"/%E5%A4%A7%E5%AD%A6%E4%BA%BA%E7%94%9F/:3:1","tags":null,"title":"大学四年，如何成为还算不错的程序员？","uri":"/%E5%A4%A7%E5%AD%A6%E4%BA%BA%E7%94%9F/"},{"categories":["个人成长"],"content":"3.2、方法\u0026量化 基于上述分析，主要讲了整体思路，大家可能会觉得有点不太好理解。接下来，拿我当时遭遇的处境进行举例阐述，这样让不同水平或时期的同学有不一样的体会。 假设回到大学时代，我会先战略性放弃计算机组成原理、操作系统原理、计算机网络等原理课，只需上课硬着头皮听个大概脑子留个印象即可，毕竟我这种全是高大上的原理，每次上课就想睡觉。当然，数据结构/算法我还能好好听听，毕竟我数学功底还行让我不排斥。事实上，我当时就是这么做的。 为什么不先深入研究计算机基础原理？ 假设你学骑自行车，你是直接上去就蹬？还是先把轮子拆下来研究清楚原理再去学习怎么蹬？根据我的经历，在新手阶段不管是接触新的语言，还是新的方向。最快的方式就是先把自行车蹬起来，等你蹬熟练了再去研究轮子是怎么造出来的。 根据上述策略，刨除我踩的一些坑，我把学习征途划分四个阶段，最终实现学习效率的最优解。 3.2.1、第一阶段：新手入门 在我入门的时候，我遇到的最大困难是代码不会写，DEBUG不会做，程序报错不会看毫无头绪，甚至大家常说的百度一下的关键字我也不知道搜。 这时候，最大的目标就是根据百度/查文档/看视频，把程序调试出预期结果，甚至你抄代码都行，很多时候抄代码你都不一定能DEBUG出预期结果。这就是现实，主要就是要把对编程的排斥消磨殆尽。 这个阶段，不需要太关注底层实现原理，最重要的工作就是把应用层面的技术，不断练习直到熟练掌握上面提到的应用纬度「 编程语言、Linux、数据库、HTTP网络协议 」。 目标：会调试、会查文档、会用搜索引擎 内容：JAVA基础语法、MYSQL数据库、Linux操作系统、HTTP通信协议 方法：只关注如何使用技术，难以理解的背下来，不关注底层原理。 成果：实现常见的管理系统模块，能部署在服务器上，供他人访问。 对于现已从事计算机行业的同学，其实这部分内容非常简单，可能按照正常水平少则几天，多则不超过一周就能开发出简单模块。简单说，它顶多是毕设设计水准，主要是让新手在感官上体验软件产品。本质上，在计算机世界里，抽象来看就是数据的计算、传输、存储。随着你的经验增多，你会发现很多技术都是诞生或优化性能都是在解决计算、存储、传输的问题。 在这里，主要让大家在系统的角度感受最简单、最初级的技术模型。 Linux操作系统：承载应用程序、数据库的运行，提供CPU供应用程序计算。 应用程序（Java/Python/Php）：JAVA主要采用Servlet、JDBC承载网络的传输、数据库连接管理。 数据库（MySQL）：主要理解关系类数据库的存储，对数据进行操作。 HTTP/TCP：熟悉重点网络协议，它分为包头/包体进行传输，包体格式可能分为form、json、pb、二进制。 3.2.2、第二阶段：项目练习 通过第一个阶段学习，你对编程从一无所知到有所斩获，对计算机世界充满了好奇，甚至有所开心。这时候，你最应该做的就是去满足你装逼的梦想。 假设你是爬虫方向，你应该去爬表情包、爬知乎数据、自动抢票，去满足你无数个装逼梦想。 假设你是算法方向，你可以去研究推荐算法、图像识别模型，去做个商品推荐、人脸识秀一秀。 假设你是后端方向，你可以去研究下网络编程/网站开发开发个仿微信聊天应用，体验下lowB版微信。 作为大学生，实验室、软件设计比赛、开源社区都是你发挥现象力的天堂，这些倒腾的经历将是你毕业时最宝贵的经历。 3.2.3、第三阶段：强化理论 经过前两个阶段实践，这时候你的软件开发水平已达到计算机毕设水平。同时，专业课如数据结构/操作系统/计算机网络也学的差不多了，对概念多多少少有初步了解。 这时候，你会发现很多原理你不懂，将很难更上一层楼。 你不知道使用ArrayList还是LinkedList？ 你不知道为什么要使用线程池？ MySQL底层原理是什么样的？ 你一直停留在写代码一时爽，一直写一直爽，从不考虑性能或规范，遇到难题就束手无策、程序直接土崩瓦解。所以，你不得不去学习理论知识让你走得更远。 问题：为什么在这个阶段强化理论知识？ 在新手阶段去强化理论知识，会让你兴趣骤减且产生学了有何用的错觉。同时，这是最好的时机，学校专业课学完你有基础概念，你有实际软件应用场景，这些东西让你深挖理论的时候会快速给你构建起基础图谱，让你兴趣激增不断体验学会的东西，将戳痛你最痛的神经，瞬间把你以前遇到的问题有新的认知，这就是答案。简单说，面向问题，解决问题，让你实实在在感受到成长，这就是成就感的力量。 问题：如何高效的学习理论？ 其实，编程语言和计算机基础都是相通的，只要你学透一门编程语言剩下的就大同小异。当然，计算机基础毕竟是枯燥无味的，学习毕竟是有方法的。站在编程语言角度，不管你用的是什么编程语言，你会发现不管什么编程语言，变来变去都是换了个花样在谈以下内容。 程序结构（数据类型、控制语句、面对对象、异常处理） 集合（list、set、map） 网络编程（IO、BIO、NIO） 并发编程（线程池） 内存管理（jvm） 不管在面试还是技术探讨，重点考察的都是集合、网络通信、线程/线程池。源自于它跟计算机基础有紧密结合，你要优化它们你必须具备扎实基本功。基于我的研究经验，我建议大家在学习计算机基础的时候，不要因为理论而理论。你应该去通过编程语言源码去学习计算机基础，只学你当前认为最重要的。 举个例子： 当我去学习数据结构/算法的时候，我会一边学习源码一边思考数据结构，这样就让我有实际应用场景不会因为理论而理论。我学习list、set源码的时候，我就学会链表、栈。我学习map的时候，我就学会了红黑树、散列表。 当我去学习计算机网络的时候，我会一边学习socket的用法，学习Linux网络通信模型epoll，这样就重点把网络协议学会了。同时，很多应用场景极少的理论知识，我就粗略记忆或者跳过，这样就节约了很多时间。 当我去学习线程/线程池的时候，我会学习锁机制、生产者/消费者模型这些操作系统原理的重要知识，跟编程语言中关联不大的我就粗略记忆。 3.2.4、第四阶段：深究专长 经过前面三个阶段的学习，你已经具备扎实基本功和项目实战经验。接下来，你需要做的就是更加的专业化，研究一些有生产意义的东西。如果你一直写学生管理系统，这些没有价值没有意义的东西，那么毫无意义。 这时候，你应该去互联网公司验证你学习的技能。除此之外，你可以去学习额外的成熟先进技术栈。这样，你就有实际业务经验，就有技术的宽度，同时又有深度，这就是你核心优势，毕竟算法/数据结构这些东西在竞争的时候大家都会。 画外音：去实习，最好去大厂实习，接受互联网软件开发的挑战。要是不能，那么去研究实际企业技术栈的应用与底层研究。 举个例子： 假设你是后端开发，你就可以去学习微服务的技术栈，springboot、dubbo、docker、hadoop都可以去学习。除此之外，设计模式，redis原理都可以去学习研究，只有这样当你去面试的时候，你有很多话题和故事讲给别人听，你的专长研究既可以让你说业务场景，你又可以讲底层原理，对答如流。 ","date":"2019-12-05","objectID":"/%E5%A4%A7%E5%AD%A6%E4%BA%BA%E7%94%9F/:3:2","tags":null,"title":"大学四年，如何成为还算不错的程序员？","uri":"/%E5%A4%A7%E5%AD%A6%E4%BA%BA%E7%94%9F/"},{"categories":["个人成长"],"content":"4、成果 经过上面的训练，已经具备了解决问题、快速学习、编写代码能力，也就是具备软件工程师的职业素养和扎实基本功。 这时候，进入互联网公司开启职业道路，你将会很快有产出，不会陷入徘徊自闭的状态。更何况，你的职业素养已经能够让你遇到问题，能快速的学习克服困难。但是，要是让你去参加面试可不一定能独善其身，毕竟工作拧螺丝，面试造火箭可不能疏忽大意。 接下来，重点讲一下如何应对面试？ 面试也就是把自己卖出去，让别人觉得你值。简历是至关重要的环节，所有的知识和技能全都是围绕它展开，否则毫无意义。因为在面试中，面试官关心你有什么，也就是面试完全围绕着你会的东西展开提问，所以你就把你的优势发挥到极致就行。 ","date":"2019-12-05","objectID":"/%E5%A4%A7%E5%AD%A6%E4%BA%BA%E7%94%9F/:4:0","tags":null,"title":"大学四年，如何成为还算不错的程序员？","uri":"/%E5%A4%A7%E5%AD%A6%E4%BA%BA%E7%94%9F/"},{"categories":["个人成长"],"content":"4.1、准备简历 简历一定要认真对待，一定要简介精炼，尽可能把内容压缩到一页，毕竟简历筛选就30秒不到。这时候，简历排版、简历字体、简历模板都有讲究，细节决定成败。 在写简历的时候，主要分为个人资料、实习经历、项目经历、专业技能。其实，没什么技巧，参考STAR原则，重点体现你在项目中的价值和思考。 要体现做了什么事情？ 遇到什么困难？ 怎么解决的？ 产出是什么？ ","date":"2019-12-05","objectID":"/%E5%A4%A7%E5%AD%A6%E4%BA%BA%E7%94%9F/:4:1","tags":null,"title":"大学四年，如何成为还算不错的程序员？","uri":"/%E5%A4%A7%E5%AD%A6%E4%BA%BA%E7%94%9F/"},{"categories":["个人成长"],"content":"4.2、梳理知识体系 以前，学习知识是零散的，学习策略更多是面向解决问题，以至于知识不系统，表达逻辑层次有限。面试官逻辑思维强，所以你必须做好充足准备才能脱颖而出。 最好的策略就是梳理知识体系和准备面经，我们都知道要是你面试官问的问题是你刚好熟悉的问题，你岂不是轻松闯关成功？所以，准备考纲、梳理知识体系、疯狂刷题这就是最好的策略。 ","date":"2019-12-05","objectID":"/%E5%A4%A7%E5%AD%A6%E4%BA%BA%E7%94%9F/:4:2","tags":null,"title":"大学四年，如何成为还算不错的程序员？","uri":"/%E5%A4%A7%E5%AD%A6%E4%BA%BA%E7%94%9F/"},{"categories":["个人成长"],"content":"4.3、技术面试 按照互联网面试流程大多数分为三轮面。 一轮面试：主要是考察计算机基础知识和擅长语言基础知识，重点考察数据结构/算法、网络编程、擅长语言基础。但是，绝对不是死记硬背的东西，一定是深度和广度紧密结合，环环相扣直到把你肚子里的东西全部挖出来。 举个例子 获取链表倒数第N个节点的值，只许遍历一次。 有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M，返回频数最高的100个词。 谈谈HashMap，说下它们的数据结构？ Key在HashCode取余以后，它可能全部堆积在某几个Key对应的链表上，这样就会造成该数据结构存储或者查询低效，那怎么解决呢？ 为什么会链表要变成红黑树，什么时候从链表变成红黑树，什么时候从红黑树变回链表？ 假设多个线程并发访问，那可能造成容器更新或者操作出现问题？ 除了使用synchronized加同步锁，还有没有其他办法解决呢？ 为什么采用CAS，能说一下ConcurrentHashMap的具体实现吗？ 你会发现每个问题都是环环相扣，从简单到难，目的就是挖掘出你的极限。大多数情况都是，从数据结构/算法入手，扩展到编程语言特性，再扩展到并发/网络编程不断进行深挖。当直接问实际用法应试者答不出来的时候，就会再次引入到计算机基础知识，这样不断反复调度试探应试者的是深度和广度。 二轮面试：这轮考察实习/项目经历，重点考察你的面试储备。众所周知，大部分应届生项目经验十分有限，大多数是图书馆管理系统、电商系统这样。重点说一下应对策略，可以去网上找你做的项目可能遇到的领域难题，去找解决办法，最终扩展补充到你的项目中。 三轮面试：这轮面试更多是经理考察应试者的基础能力。也就是逻辑思维、抗压、时间管理等基础能力，看下是否能融入团队，毕竟适合团队的才是最好的。 总之，作为普通学校的同学，你只有花更加多的时间在项目实战中，实习/打比赛/逛开源社区，这些时间让你更快接近成为职业软件工程师。当机会来临的时候，你抓住机会就踏入大厂的大门了，幸运永远不会无缘无故眷顾你。 ","date":"2019-12-05","objectID":"/%E5%A4%A7%E5%AD%A6%E4%BA%BA%E7%94%9F/:4:3","tags":null,"title":"大学四年，如何成为还算不错的程序员？","uri":"/%E5%A4%A7%E5%AD%A6%E4%BA%BA%E7%94%9F/"}]