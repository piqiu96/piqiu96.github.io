[{"categories":["效率工具"],"content":"图床 网址：https://www.jsdelivr.com/?docs=gh 示例：https://cdn.jsdelivr.net/gh/piqiu96/aqiucdn/imgs/wxicon2.jpg ","date":"2021-12-05","objectID":"/%E5%86%99%E4%BD%9C%E5%B7%A5%E5%85%B7/:1:0","tags":["写作"],"title":"写作工具","uri":"/%E5%86%99%E4%BD%9C%E5%B7%A5%E5%85%B7/"},{"categories":["效率工具"],"content":"公众号排版 https://www.mdnice.com/ http://md.aclickall.com/ http://blog.didispace.com/tools/online-markdown/ ","date":"2021-12-05","objectID":"/%E5%86%99%E4%BD%9C%E5%B7%A5%E5%85%B7/:2:0","tags":["写作"],"title":"写作工具","uri":"/%E5%86%99%E4%BD%9C%E5%B7%A5%E5%85%B7/"},{"categories":["效率工具"],"content":"代码排版 https://carbon.now.sh/ ","date":"2021-12-05","objectID":"/%E5%86%99%E4%BD%9C%E5%B7%A5%E5%85%B7/:3:0","tags":["写作"],"title":"写作工具","uri":"/%E5%86%99%E4%BD%9C%E5%B7%A5%E5%85%B7/"},{"categories":null,"content":"排序算法 ","date":"2021-10-31","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:0:0","tags":null,"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":null,"content":"一、算法分类 插入排序 直接插入排序 希尔排序 交换排序 冒泡排序 快速排序 选择排序 简单选择排序 堆排序 归并排序 二路归并排序（递归实现） ","date":"2021-10-31","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:1:0","tags":null,"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":null,"content":"二、算法实现 ","date":"2021-10-31","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:2:0","tags":null,"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":null,"content":"2.1、插入排序 2.1.1、直接插入排序 数组：12,15,9,20,6,31,24,2,17,35 有序区{12,15} 无序区{9,20,6,31,24,2,17,35} 思路： 将无序区的第一个元素，称为候选元素。 将候选元素与有序区元素比较，选择适当位置插入。 public class InsertionSort { public static void sort(int [] array){ for(int i=1;i\u003carray.length;i++){ for(int j=i;j\u003e=1 \u0026\u0026 array[j]\u003carray[j-1];j--){ int temp =array[j]; array[j]=array[j-1]; array[j-1]=temp; } } } public static void main(String [] args){ int [] array={12,15,9,20,6,31,24,2,17,35}; InsertionSort.sort(array); System.out.println(Arrays.toString(array)); } } 2.1.2、希尔排序 产生：直接插入排序在基本正序的时候，排序效率高，所以把数组拆分很多个小数组，进行简单排序 思路： 将数组分组，间距从[d=n/2-1]，变换d=d/2 分别将不同分区进行直接插入排序。 当d=1，合并所有的分区进行直接插入排序 public class ShellSort { //采取分区 public static void sort(int [] array){ for(int d=array.length/2;d\u003e=1;d=d/2){ insertSort(array,d); } } //插入排序 public static void insertSort(int [] array,int d){ for(int i=d;i\u003carray.length;i++){ for(int j=d;j\u003e=d \u0026\u0026 array[j]\u003carray[j-d];j=j+d){ int temp=array[j]; array[j]=array[j-d]; array[j-d]=temp; } } } public static void main(String [] args){ int [] array={12,15,9,20,6,31,24,2,17,35,5}; InsertionSort.sort(array); System.out.println(Arrays.toString(array)); } } ","date":"2021-10-31","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:2:1","tags":null,"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":null,"content":"2.2、交换排序 2.2.1、冒泡排序 数组：12,15,9,20,6,31,24,2,17,35 无序区：{12,15,9,20,6,31,24,2,17} 有序区：{35} 问题： 如何确定需要冒泡排序范围，保证有序记录不参加下一趟的排序？ 如何判断冒泡排序结束？ 思路： 从数组头开始，候选元素跟后继元素比较，通过交换选出最大元素，直到无序区选出最大元素放入有序区的。 记录有序区的头索引，将不参加下一趟排序。 当没有元素交换，冒泡排序结束。 public class BubbleSort { public static void sort(int [] array){ int exchange=array.length; //判断无序列是否有交换，冒泡排序结束标志 while(exchange!=0){ //无序区的边界 int bound=exchange; exchange=0; for(int i=1;i\u003cbound;i++){ if(array[i]\u003carray[i-1]){ int temp=array[i]; array[i]=array[i-1]; array[i-1]=temp; exchange=i; } } } } public static void main(String [] args){ int [] array={12,15,9,20,6,31,24,2,17,35,5}; BubbleSort.sort(array); System.out.println(Arrays.toString(array)); } } 2.2.2、快速排序 数组：12,15,9,20,6,31,24,2,17,35 思路： 一次快速划分。选择轴值，最终轴值左侧小于轴值，轴值右侧大于轴值。 例如：最初选择轴值为12，通过一次快速划分，{2,6,9,12,15,20,17,35,31} 对轴值左侧、轴值右侧。 递归调用一次快速划分。 public class QuickSort { public static int partition(int [] array,int low,int high){ int i=low; int j=high; int temp; //当i==j,结束一次快速划分 while(i\u003cj){ //向右侧扫描 while(i\u003cj \u0026\u0026 array[i]\u003carray[j]) j--; //说明轴值大于array[j],交换轴值变成array[j] if(i\u003cj){ temp=array[i]; array[i]=array[j]; array[j]=temp; i++; } //向左侧扫描 while(i\u003cj \u0026\u0026 array[i]\u003carray[j]) i++; if(i\u003cj){ temp=array[i]; array[i]=array[j]; array[j]=temp; j--; } } return i; } public static void sort(int [] array,int low,int high){ if(low\u003chigh){ int mid =partition(array, low, high); sort(array, low, mid-1); sort(array, mid+1, high); } } public static void main(String [] args){ int [] array={12,15,9,20,6,31,24,2,17,35,5}; QuickSort.sort(array, 0, array.length-1); System.out.println(Arrays.toString(array)); } } ","date":"2021-10-31","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:2:2","tags":null,"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":null,"content":"2.3、选择排序 2.3.1、简单选择排序 数组：12,15,9,20,6,31,24,2,17,35 有序区：{} 无序区：{12,15,9,20,6,31,24,2,17,35 } 思路 把无序区的最小元素，采用选择方式放入有序区末尾 public class SelectSort { public static void sort(int [] array){ int index; for(int i=0; i\u003carray.length; i++){ index=i; for(int j=i; j\u003carray.length; j++){ if(array[j] \u003c array[index]) index = j; } if(index != i){ int temp = array[i]; array[i] = array[index]; array[index] = temp; } } } public static void main(String [] args){ int [] array={12,15,9,20,6,31,24,2,17,35,5}; SelectSort.sort(array); System.out.println(Arrays.toString(array)); } } 2.3.2、堆排序 数组：12,15,9,20,6,31,24,2,17,35 思路： 把候选元素构建成大根堆。 从数组最后一个元素开始遍历，把大根堆的最大元素放入有序区。 去掉有序区元素，重新调整大根堆。 public class HeapSort { //根据候选元素，构建成大根堆 public static void adjustHeap(int [] array,int i,int len){ int j=0; int temp=array[i]; for(j=i*2;j\u003clen;j=j*2){ if( j\u003clen \u0026\u0026 array[j]\u003carray[j+1]) j++; if(temp\u003e=array[j]) break; array[i]=array[j]; i=j; } array[i]=temp; } public static void sort(int [] array){ int i; //选非叶子节点，构造大根堆 for(i=array.length/2-1;i\u003e=0;i--){ adjustHeap(array, i, array.length-1); } //不断选大根堆最大元素放入有序区 for(i=array.length-1;i\u003e=0;i--){ int temp=array[0]; array[0]=array[i]; array[i]=temp; adjustHeap(array, 0, i-1); } } public static void main(String [] args){ int [] array={12,15,9,20,6,31,24,2,17,35,5}; HeapSort.sort(array); System.out.println(Arrays.toString(array)); } } ","date":"2021-10-31","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:2:3","tags":null,"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":null,"content":"2.4、归并排序 2.4.1、二路归并排序 数组：12,15,9,20,6,31,24,2,17,35 思路： 利用一次归并算法将两个分区元素，归并到一个数组里。 先把数组划分成长度为1的序列区间，利用递归的方式，归并到一个序列里。 public class MergeSort { public static void merge(int [] array,int low,int mid,int high){ int [] tempArray=new int[high-low+1]; int i=low; int j=mid+1; int k=0; while(i\u003c=mid \u0026\u0026 j\u003c=high){ if(array[i]\u003c=array[j]){ tempArray[k++]=array[i++]; }else{ tempArray[k++]=array[j++]; } } //把第一个分片序列，处理余下数据 while(i\u003c=mid){ tempArray[k++]=array[i++]; } //把第二个分片序列，处理余下数据 while(j\u003c=high){ tempArray[k++]=array[j++]; } //把临时数组的数据加入到原数组 for(int k2=0;k2\u003ctempArray.length;k2++){ array[low+k2]=tempArray[k2]; } } public static void sort(int [] array,int low, int high){ int mid=(low+high)/2; if(low\u003chigh){ sort(array, low, mid); sort(array, mid+1, high); merge(array, low, mid, high); } } public static void main(String [] args){ int [] array={12,15,9,20,6,31,24,2,17,35,5}; MergeSort.sort(array,0,array.length-1); System.out.println(Arrays.toString(array)); } } ","date":"2021-10-31","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:2:4","tags":null,"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["推荐书单"],"content":"📚 经典技术书籍 PDF 文件，涵盖：编程语言、计算机系统、网络协议、数据库、代码艺术、设计模式、算法与数据结构、系统架构、微服务、测试、程序员职业修炼等相关书籍。 版权原因，保留书单 可以找找别人的 fork 版本 ","date":"2021-10-14","objectID":"/booklist/:0:0","tags":["读书"],"title":"经典书单","uri":"/booklist/"},{"categories":["推荐书单"],"content":"Java 《Effective Java 中文版（第 2 版）》 《Java 编程思想（第 4 版）》 ","date":"2021-10-14","objectID":"/booklist/:1:0","tags":["读书"],"title":"经典书单","uri":"/booklist/"},{"categories":["推荐书单"],"content":"C 《C 程序设计语言（第 2 版）》 《C 专家编程》 《C 语言接口与实现》 《C 陷阱与缺陷》 ","date":"2021-10-14","objectID":"/booklist/:2:0","tags":["读书"],"title":"经典书单","uri":"/booklist/"},{"categories":["推荐书单"],"content":"C++ 《C++ Primer Plus（第 5 版）》 《C++编程思想（第 1 卷）》 ","date":"2021-10-14","objectID":"/booklist/:3:0","tags":["读书"],"title":"经典书单","uri":"/booklist/"},{"categories":["推荐书单"],"content":"Golang 《Go 学习笔记（第 4 版）》 《Go 学习笔记（第 6 版下卷）》 《Go 源码剖析》 《Go 程序设计语言》 《Go 语言实战》 ","date":"2021-10-14","objectID":"/booklist/:3:1","tags":["读书"],"title":"经典书单","uri":"/booklist/"},{"categories":["推荐书单"],"content":"Python 《Python 基础教程（第 2 版）》 《Python 编程：从入门到实践》 《Python 核心编程（第 2 版）》 《Python Cookbook（第 3 版）》 《Python 源码剖析》 ","date":"2021-10-14","objectID":"/booklist/:3:2","tags":["读书"],"title":"经典书单","uri":"/booklist/"},{"categories":["推荐书单"],"content":"Computer system 《深入理解计算机系统》 《现代操作系统（第 4 版）》 《编码：隐匿在计算机软硬件背后的语言》 《计算机程序的构造和解释（第 2 版）》 《计算的本质：深入剖析程序和计算机》 《编译原理（第 2 版）》 ","date":"2021-10-14","objectID":"/booklist/:4:0","tags":["读书"],"title":"经典书单","uri":"/booklist/"},{"categories":["推荐书单"],"content":"Linux / Unix 《UNIX 编程艺术》 《UNIX 环境高级编程（第三版）》 《UNIX 网络编程卷 1：套接字 API》 《UNIX 网络编程卷 2：进程间通信》 《UNIX 操作系统设计》 《Linux 内核设计与实现（第三版）》 《深入 Linux 内核架构》 《深入理解 linux 内核（第三版）》 《跟我一起写 makefile》 ","date":"2021-10-14","objectID":"/booklist/:5:0","tags":["读书"],"title":"经典书单","uri":"/booklist/"},{"categories":["推荐书单"],"content":"TCP 《TCP/IP 详解 卷 1：协议》 《TCP/IP 详解 卷 2：实现》 《TCP/IP 详解 卷 3：TCP 事务协议，HTTP，NNTP 和 UNIX 域协议》 ","date":"2021-10-14","objectID":"/booklist/:6:0","tags":["读书"],"title":"经典书单","uri":"/booklist/"},{"categories":["推荐书单"],"content":"HTTP 《HTTP 权威指南》 《Web 性能权威指南》 《图解 HTTP》 ","date":"2021-10-14","objectID":"/booklist/:7:0","tags":["读书"],"title":"经典书单","uri":"/booklist/"},{"categories":["推荐书单"],"content":"Clean code 《代码整洁之道》 《代码大全》 《编写可读代码的艺术》 《修改代码的艺术》 《重构：改善既有代码的设计》 《程序设计方法》 《程序设计实践》 《领域驱动设计：软件核心复杂性应对之道》 ","date":"2021-10-14","objectID":"/booklist/:8:0","tags":["读书"],"title":"经典书单","uri":"/booklist/"},{"categories":["推荐书单"],"content":"Design pattern 《Head First 设计模式》 《设计模式：可复用面向对象软件的基础》 《设计模式之禅》 ","date":"2021-10-14","objectID":"/booklist/:9:0","tags":["读书"],"title":"经典书单","uri":"/booklist/"},{"categories":["推荐书单"],"content":"Algorithms 《算法（第 4 版）》 《算法导论（第 2 版）》 《算法设计与分析（第 3 版）》 《算法心得：高效算法的奥秘（第 2 版）》 《数据结构与算法分析：C 语言描述（第 2 版）》 《数据结构与算法分析：Java 描述》 《编程珠玑（第 2 版）》 《编程之美：微软技术面试心得》 《剑指 offer 名企面试官精讲典型编程题》 ","date":"2021-10-14","objectID":"/booklist/:10:0","tags":["读书"],"title":"经典书单","uri":"/booklist/"},{"categories":["推荐书单"],"content":"System 《高性能网站建设指南》 《大型网站技术架构：核心原理与案例分析》 《企业应用架构模式》 《企业集成模式：设计、构建及部署消息传递解决方案》 ","date":"2021-10-14","objectID":"/booklist/:11:0","tags":["读书"],"title":"经典书单","uri":"/booklist/"},{"categories":["推荐书单"],"content":"Microservice 《微服务设计》 ","date":"2021-10-14","objectID":"/booklist/:12:0","tags":["读书"],"title":"经典书单","uri":"/booklist/"},{"categories":["推荐书单"],"content":"Test 《测试驱动开发》 ","date":"2021-10-14","objectID":"/booklist/:13:0","tags":["读书"],"title":"经典书单","uri":"/booklist/"},{"categories":["推荐书单"],"content":"Git 《Pro Git 中文版》 《GitHub 入门与实践》 ","date":"2021-10-14","objectID":"/booklist/:14:0","tags":["读书"],"title":"经典书单","uri":"/booklist/"},{"categories":["推荐书单"],"content":"Docker 《Docker 从入门到实践（第 3 版）》 《Docker 容器与容器云（第 2 版）》 ","date":"2021-10-14","objectID":"/booklist/:15:0","tags":["读书"],"title":"经典书单","uri":"/booklist/"},{"categories":["推荐书单"],"content":"MySQL 《高性能 MySQL（第 3 版）》 《MySQL 性能调优与架构设计》 《MySQL 技术内幕：InnoDB 存储引擎》 《SQL 基础教程（第 3 版）》 《MySQL 必知必会》 《SQL 学习指南》 ","date":"2021-10-14","objectID":"/booklist/:16:0","tags":["读书"],"title":"经典书单","uri":"/booklist/"},{"categories":["推荐书单"],"content":"MongoDB 《MongoDB 实战》 《MongoDB 权威指南》 《深入学习 MongoDB》 ","date":"2021-10-14","objectID":"/booklist/:17:0","tags":["读书"],"title":"经典书单","uri":"/booklist/"},{"categories":["推荐书单"],"content":"Redis 《Redis 入门指南（第 2 版）》 《Redis 实战》 《Redis 设计与实现》 《Redis 开发与运维》 ","date":"2021-10-14","objectID":"/booklist/:18:0","tags":["读书"],"title":"经典书单","uri":"/booklist/"},{"categories":["推荐书单"],"content":"Nginx 《深入理解 Nginx：模块开发与架构解析（第 2 版）》 ","date":"2021-10-14","objectID":"/booklist/:19:0","tags":["读书"],"title":"经典书单","uri":"/booklist/"},{"categories":["推荐书单"],"content":"Others 《如何阅读一本书》 《七周七语言：理解多种编程范型》 《程序员修炼之道：从小工到专家》 《程序员的职业素养》 《程序员的自我修养：链接、装载与库》 《高效程序员的 45 个习惯》 ","date":"2021-10-14","objectID":"/booklist/:20:0","tags":["读书"],"title":"经典书单","uri":"/booklist/"},{"categories":null,"content":"一、概念 ","date":"2020-12-04","objectID":"/git%E5%AE%9E%E6%88%98/:1:0","tags":null,"title":"Git速查","uri":"/git%E5%AE%9E%E6%88%98/"},{"categories":null,"content":"1.1. Git是什么？ GIT是分布式版本控制系统，简单分解就是：分布式 + 版本控制 + 系统，核心要素就是版本控制。 问题：怎么理解版本控制，想想我们生活工作中的场景？ 1、假设没有版本控制系统，你上线代码会做什么事情？（假设你不做，出现问题你怎么办？） 备份原文件，重命名 niubi.php.20200520 复制修改后文件移动到制定项目路径 2、当我们还是单机mysql数据库，对稳定要求不高，只需具备快速切换能力即可，这种场景你会怎么做？ 方案一：对数据库做版本控制，定时dump数据库文件，数据库文件名（XX.sql.时间时刻） 方案二：做数据库主从，主库挂掉，脚本快速切换到从库 3、当你写毕业论文的时候，写了N年的论文丢了你怕不怕，为了防止这操作你常见的操作是什么？ 老师想看论文，阿邱同学提交论文，命名：阿邱同学毕业论文_V1 老师想看论文，阿邱同学提交论文，命名：阿邱同学毕业论文_V2 …… 老师想看论文，阿邱同学提交论文，命名：阿邱同学毕业论文_V死不改版 本质上，版本控制本质上就是把每次文件（数据）集合打个标记（版本），让自己快速跳转到目标版本。最终，实现代码可以随意切换到随意版本的代码，当出现问题能快速切换到稳定版本。 ","date":"2020-12-04","objectID":"/git%E5%AE%9E%E6%88%98/:1:1","tags":null,"title":"Git速查","uri":"/git%E5%AE%9E%E6%88%98/"},{"categories":null,"content":"1.2 为什么要用Git？ 不管人类还是软件，都会遇到类似的问题，版本控制系统诞生无非是苦秦久矣罢了。还有细心思考下，不光是代码，凡是需要存储的内容（文件、数据库）都需要版本控制，不然任何一环故障都会影响系统。 其实，在Git出现前就出现很多版本控制系统，主流思想无非就是增量或全量，Git采用的全量快照的方式，把修改的文件集合打个版本。 增量：每次记录变化的内容，恢复的时候依据 基准版本 + 增量版本回滚。 全量：每次记录本次变更的所有文件放入缓存区，恢复的时候直接缓存区找到全量版本回滚。 于是，GIt有几个核心流程和核心概念。 核心概念：文件流转状态（已提交、已修改、已暂存），为了可通过文件状态跟踪出文件内容，于是git项目有三个阶段：工作区、暂存区以及 Git 目录。 核心流程： 在工作区中修改文件。 将你想要下次提交的更改选择性地暂存，这样只会将更改的部分添加到暂存区。 提交更新，找到暂存区的文件，将快照永久性存储到 Git 目录。 ","date":"2020-12-04","objectID":"/git%E5%AE%9E%E6%88%98/:1:2","tags":null,"title":"Git速查","uri":"/git%E5%AE%9E%E6%88%98/"},{"categories":null,"content":"二、实战 场景一：添加如何代码，提cr git pull git add \u003cfile\u003e git commit -m \"commit message\" 场景二：回滚commit 说明 提交非预期代码，需要回滚重新提交 git log git reset --soft '版本号' git reset --soft HEAD^ 回滚到上次提交 场景三: 切换分支且拉取代码 说明 主要用于项目初始化，切换分支且拉取代码 git branch -a git checkout -b \u003cbranch_local\u003e orign/\u003cbranch_remote\u003e baranch_local: 本地分支名，可自定义随意 branch_remote：远程分支名，必须是仓库内名 场景四：多个commit合并 说明 通常情况，我们设置一次CR只允许一次commit，如何把多次commit合并到同一commit？ git reset --soft HEAD^ git commit --amend git push origin \u003cremote\u003e 场景五：代码冲突 说明 代码冲突是最常见的问题，也是很头大的问题 方法一：保留服务器改动，仅合入远程仓库新增配置项，标记出冲突代码！ git stash git pull git stash pop 方法二：用远程仓库代码库文件完全覆盖本地文件，强制回滚！（慎用） git reset --hard git pull ","date":"2020-12-04","objectID":"/git%E5%AE%9E%E6%88%98/:2:0","tags":null,"title":"Git速查","uri":"/git%E5%AE%9E%E6%88%98/"},{"categories":null,"content":"参考资料 https://www.liaoxuefeng.com/wiki/896043488029600 https://git-scm.com/book/zh/v2 ","date":"2020-12-04","objectID":"/git%E5%AE%9E%E6%88%98/:3:0","tags":null,"title":"Git速查","uri":"/git%E5%AE%9E%E6%88%98/"}]